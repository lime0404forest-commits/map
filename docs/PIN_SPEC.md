# 地図エディタ・ピン仕様書

## 用途
ゲームブログ用インタラクティブマップの「ピン」を登録・管理する。  
**地図上の地点を選択 → 情報を入力 → 保存** の流れで、座標とメタデータを再利用可能に分類・保存する。

---

## 現状のデータ構造（整理）

### 3層の意味づけ

| 層 | 名前 | 意味 | 例（StarRupture） |
|----|------|------|-------------------|
| 1 | **オブジェクト** | ピンが指す「見た目・外形」 | ストレージボックス、遺体、地下洞窟 |
| 2 | **カテゴリ** | 中身の「分類」 | 設計図、LEM、戦時債権、交換アイテム |
| 3 | **アイテム＋属性** | その分類内の「具体内容」 | チューブ / 上級・リローダーLEM / 不明なロジックボード(400pt) |

- **オブジェクト** … `attr_mapping` で管理。`type`（loot / landmark / colony / other）でフィルタ・表示を制御。
- **カテゴリ** … `category_master` で管理。`input_type`（アイテム選択 or 数量のみ）、`show_qty` で入力形態を切り替え。
- **アイテム** … `item_master[カテゴリ]` で管理。各アイテムは `attributes` で「カテゴリ・アイテムごとに違う追加情報」に対応（ランク、ポイント等）。

1ピン = **オブジェクト1つ** + **中身スロット複数**（カテゴリ＋アイテム＋数量＋属性）。  
「中身の種類と数がカテゴリ・アイテムごとに違う」という要件は、現状のスキーマで表現できている。

---

## 最適化の方向性

### 変えなくてよい部分（仕様の強み）
- **オブジェクト → カテゴリ → アイテム** の3層は、ゲームの意味（見た目／分類／具体）と一致しており、そのまま維持するのがよい。
- **カテゴリ・アイテムごとに属性の数・種類が違う** のは、`category_master` の `input_type` / `show_qty` と、`item_master` の `attributes`（select / number / fixed）で既に実現できている。
- 1ピンに**中身スロットを複数**持たせる構造は、現状の `categories_data` で正しく保存・読込できている。

### 最適化のポイント

1. **用語の統一（UI・ドキュメント）**
   - 画面上のラベルを「何を選んでいるか」が分かるようにする。
   - 例：`▼ オブジェクト (必須)` → `▼ オブジェクト（見た目・外形）`、  
     `▼ カテゴリ` → `▼ 中身の分類（カテゴリ）`、その下を「中身の詳細（アイテム・数量・属性）」など。
   - 設定画面でも「オブジェクト＝見た目」「カテゴリ＝中身の分類」「アイテム＝中身の具体」と揃える。

2. **入力の負荷を下げる**
   - **オブジェクト選択時**  
     - 下位が不要なタイプ（例：landmark）のときは、カテゴリを「(なし)」のみのフィルタ状態にして、入力欄は表示したままにする（実装済み想定）。
   - **カテゴリ・アイテム**
     - コンボボックスは「入力可」のままにして、**新しい名前を入力して保存 → マスタに自動追加** で、登録作業を1回で済ませる（実装済み想定）。
   - **よく使う組み合わせ**
     - 将来的に「ピン定型（プリセット）」を用意する余地を残す。  
       例：「ストレージボックス ＋ 設計図 ＋ チューブ」を定型として保存し、ピン作成時に「定型を適用 → 座標だけ変える」で効率化。

3. **マスタ定義のルール（運用で揃える）**
   - **オブジェクト**  
     - 1項目 = 地図上の「見た目」1種類。属性は「そのオブジェクト固有の情報」だけ（例：遺体の「場所」）。
   - **カテゴリ**  
     - 1項目 = 中身の「種類」1つ。`input_type` で「アイテムを選ぶか / 数量だけか」を決める。
   - **アイテム**  
     - カテゴリごとの「具体名」。`attributes` で、そのアイテムだけの追加情報（ランク、ポイント等）を定義。  
     - ピン編集では「マスタに登録した値は固定表示」（例：ポイント）、マスタ管理画面でのみ編集可能にする、など運用を決めておく。

4. **保存データの意味をはっきりさせる**
   - 1ピン = `attribute`（オブジェクトID） + `obj_attributes`（オブジェクト固有属性） + `categories`（中身スロットの配列）。
   - 各スロット = `category` + `item_id` + `item_name_jp/en` + `qty` + `attributes`（アイテム固有属性）。
   - ブログやエクスポートで使うときは、「オブジェクト名＋中身の要約（例：設計図・チューブ×1）」のように、この構造から表示用テキストを組み立てる。

---

## 推奨する「最適な仕様」まとめ

- **データ構造**  
  - 現状の3層（オブジェクト / カテゴリ / アイテム＋属性）と、`config.json` の `attr_mapping`, `category_master`, `item_master` をそのまま活かす。
- **拡張のルール**  
  - 新しい「見た目」→ オブジェクト追加。  
  - 新しい「中身の種類」→ カテゴリ追加（`input_type` / `show_qty` を設定）。  
  - 新しい「具体名」や「ランク・ポイントなどの項目」→ アイテムおよび `attributes` を追加。
- **入力効率**  
  - マスタにない名前はピン編集で入力→保存で自動登録。  
  - オブジェクトで下位不要なときはカテゴリをフィルタしつつ入力欄は表示。  
  - （将来）よく使う組み合わせは「ピン定型」で一発入力。

このようにすると、**仕様の複雑さを増さずに**、分類・再利用・拡張をしやすい形にできます。

---

## 推奨ピン構造（JSON）— データ軽量化とブログ表示の両立

「場所・外見（不変）」と「中身スロット（可変）」をはっきり分けた形が、**データ軽量化**と**ブログ表示の柔軟性**の両方に有利です。

### 1ピンが持つ情報（JSON 例）

```json
{
  "id": "p12345",
  "coords": [120.5, 65.3],
  "obj_id": "STORAGE_BOX",
  "obj_props": {
    "場所": "洞窟内"
  },
  "contents": [
    {
      "cat_id": "blueprint",
      "item_id": "Tube",
      "qty": 1,
      "props": {}
    },
    {
      "cat_id": "lem",
      "item_id": "Reloader LEM",
      "qty": 1,
      "props": { "ランク": "上級" }
    },
    {
      "cat_id": "war_bonds",
      "item_id": null,
      "qty": 12,
      "props": {}
    }
  ],
  "importance": 3,
  "note_jp": "周囲にエリート敵あり",
  "note_en": "Elite enemies nearby",
  "updated_at": "2026-02-04T12:00:00"
}
```

### この構造のポイント

| 要素 | 役割 |
|------|------|
| **`obj_id`** | 見た目・フィルタ用。地図アイコンや「宝箱だけ表示」はこれだけで判定。 |
| **`obj_props`** | 外形だけの状態（鍵付き・壊れ具合など）。中身に依存しない属性。 |
| **`contents`** | 中身のスロット配列。「設計図＋LEMが両方入っている」を自然に表現。 |
| **`cat_id`** | カテゴリはIDで保持。表示側でマスタから「設計図」「LEM」などのラベルを生成。 |
| **`item_id` と `props`** | 具体名があるものは `item_id` でマスタ参照。数量だけのもの（戦時債権など）は `item_id: null` で `qty` のみ。追加属性は `props` に格納し、マスタを肥大化させない。 |

### 名前はIDで持つ「生存戦略」

- ピンには**表示名を直接書かず、`obj_id` / `cat_id` / `item_id` だけ**を保存する。
- 表示名（日本語・英語）は**マスタを1箇所**で管理し、ブログ・エクスポート時にマスタから解決する。
- 公式アップデートでアイテム名が変わっても、**マスタを直すだけで全ピンの表記が一括更新**できる。別ゲーム（VEINなど）に移植するときも、`config.json`（マスタ）を差し替えるだけで立ち上げやすい。

### オブジェクト・中身のEN（英語）の扱い

| 対象 | どこでENを管理するか | 仕様 |
|------|----------------------|------|
| **オブジェクト** | `config.json` の `attr_mapping` 各項目 | `name_jp`（必須）と `name_en`（任意）。マスタ管理の「オブジェクト」タブで「表示名(JP)」「表示名(EN)」を編集。ブログ用エクスポート時に `obj_jp` / `obj_en` としてマスタから解決。 |
| **カテゴリ** | `config.json` の `category_master` 各項目 | 表示名JP をキーに、`name_en` を dict で保持。マスタ管理の「カテゴリ」タブで「カテゴリ名(JP)」「カテゴリ名(EN)」を編集。エクスポート時は `cat_id` から `cat_jp` / `cat_en` を解決。 |
| **アイテム** | `config.json` の `item_master[カテゴリ][item_id]` | 各アイテムに `name_jp` と `name_en`。マスタ管理の「アイテム」タブで「名前(JP)」「名前(EN)」を編集。エクスポート時はマスタから `item_jp` / `item_en` を解決（未設定時はピンに保存された値があればフォールバック）。 |
| **ピン個別の表示名** | ピン編集の「表示名の例外入力」 | そのピンだけ JP/EN を上書きしたいときだけ入力。通常は空でOK（マスタの値を使用）。ブログ用エクスポートでマスタ解決後にこの値で上書き。 |

- **EN 未設定時:** マスタの `name_en` が空の場合は、エクスポート結果の `*_en` も空になる。ブログ側で「EN が空なら JP を表示」などフォールバックするかはブログ実装次第。
- **EN 一括設定:** マスタ管理の「EN一括設定」タブで、オブジェクト・カテゴリ・アイテムのうち `name_en` が空の項目を **name_jp の値で name_en にコピー**して保存できる。英語表記を付けていない項目を、とりあえず日本語で埋めておく用途。

---

## 現行実装との対応

| 提案JSON | 現行（CSV + categories JSON） | 対応状況 |
|----------|-------------------------------|----------|
| `id` | `uid` | ✅ 同等 |
| `coords` | `x`, `y` | ✅ 同等 |
| `obj_id` | `attribute`（例: STORAGE_BOX） | ✅ 既にID |
| `obj_props` | `obj_attributes`（JSON） | ✅ 同等 |
| `contents[]` | `categories`（JSON配列） | ✅ 配列で実装済み |
| `cat_id` | `category`（現在は**表示名**で保存） | ⚠️ カテゴリにIDを導入すると完全一致 |
| `item_id`, `qty`, `props` | `item_id`, `qty`, `attributes` | ✅ 同等（props＝attributes） |
| `note` | `memo_jp`, `memo_en` | ✅ 多言語のため2フィールドのままでも可 |
| `updated_at` | （なし） | 📌 追加するとブログ・キャッシュに有利 |

現行でも「中身スロットを配列で持つ」形になっている。完全に提案形に寄せる場合は、**カテゴリを `cat_id` で保存する**ようにし、マスタ側に `category_master` の各項目に `id`（例: `blueprint`, `lem`）を持たせるとよい。

---

## 入力フローとUIのトランスフォーム（アイテム別）

**「カテゴリを選択した瞬間に、その下の入力欄（属性）がそのアイテム専用の形に変わる」** ことが、この設計の強みです。

### アイテム別・入力手順とUI挙動

| ケース | 特性 | 手順 | UI挙動 |
|--------|------|------|--------|
| **LEM** | 種類＋「ランク」の追加属性 | カテゴリ「LEM」→ アイテム「リローダー」→ **ランクを3択で選択** | `item_master` の `attributes`（type: select）に基づきセレクト／ラジオを自動生成 |
| **交換アイテム** | アイテムごとにポイント固定・編集不可 | カテゴリ「交換アイテム」→ アイテム「不明なロジックボード」→ **ポイントは表示のみ** | `attributes` の type: `fixed` で値（例: 400）をテキスト表示。入力欄は出さない |
| **戦時債権** | 具体名なし・数量のみ | カテゴリ「戦時債権」→ **数量だけ入力** | `category_master` の `input_type: "qty_only"` でアイテム選択をスキップし、数量入力のみ表示 |

### この仕様で対応できないもの

**「オブジェクト ＞ カテゴリ ＞ アイテム ＋ 可変属性」** の構造で対応できないものはほぼありません。  
「ランダムで中身が変わる（A or B）」など不確定要素は、**メモ欄**や属性の「備考」で補足すれば運用可能です。

### 手間の最小化（まとめ）

| ケース | 手間を最小化する仕組み |
|--------|------------------------|
| **場所のみ** | `landmark` 等選択時に下位入力エリアを**非表示**にし、追加ボタンも無効化。 |
| **数量のみ** | `input_type: "qty_only"` でアイテム名選択をスキップ。 |
| **固定値あり** | `attributes` の type: `fixed` で、アイテム選択と同時に値が自動表示（編集不可）。 |

---

## 階層制御のロジック（UI最適化の鉄則）

「上位が決まれば下位が決まる、あるいは不要」というルールで、無駄な表示・操作を削ります。

### ルール①：下位項目が存在しないなら「非表示」

- **対象:** `landmark`（モノリス等）のように、中身（カテゴリ）が定義されていないオブジェクト。
- **挙動:** オブジェクト選択時、**「中身スロット」エリア全体（カテゴリ・アイテム入力）を DOM から隠す**（pack_forget / display:none）。
- **メリット:** 「ここは場所だけ保存すればいい」と一瞬で理解でき、迷いが消える。

### ルール②：下位が確定なら「表示（ReadOnly）のみ」

- **対象:** 交換アイテム（ポイント固定）のように、アイテムを選んだ時点で属性が決まっているケース。
- **挙動:** アイテム選択時、属性を**入力不可のテキスト表示**または **Disabled な入力欄**にする。
- **メリット:** 確認するだけでよく、打ち込み手間と誤入力リスクがゼロになる。

### アイテム別・UIの変化イメージ

| 上位項目（選択済み） | 下位項目の状態 | UIの具体的な見た目 |
|----------------------|----------------|---------------------|
| **オブジェクト:** モノリス | **下位なし** | カテゴリ・アイテムの入力エリアが**消える**。 |
| **カテゴリ:** 戦時債権 | **アイテムなし / 数量あり** | アイテム選択欄が**消え**、数量入力だけが**残る**。 |
| **アイテム:** ロジックボード | **属性確定（400pt）** | 入力欄は出さず、**「400 pt」というテキスト表示のみ**。 |
| **アイテム:** リローダーLEM | **属性未確定（3択）** | ランク選択（下級・中級・上級）の**セレクト／ラジオが出現**。 |

### Config で持たせる設定（ハードコードしない）

- **オブジェクトに「中身なし」を指定:** `attr_mapping` の `type: "landmark"` で下位を非表示。将来的に `input_type: "none"` をオブジェクトに持たせても可。
- **カテゴリの入力形態:** `category_master` の `input_type: "item_select"` / `"qty_only"`。
- **アイテムの固定値表示:** `item_master` の `attributes` で `{ "type": "fixed", "value": "400" }` など。

---

## エディタ側の「賢い」挙動

### ① オブジェクト（見た目）による中身の制限

- `landmark`（モノリス等）を選んだときは、**中身スロット用のエリア全体を非表示**にし、**「カテゴリ追加」ボタンも非活性**にする（ルール①）。
- それ以外のオブジェクトでは、カテゴリリストを type でフィルタしつつ、中身エリアと追加ボタンを表示する。

### ② マスタ自動追加時の確認

- コンボボックスに**新しい文字列**を入力して保存する際、「**新しいカテゴリ（分類）として登録**」「**新しいアイテム（具体名）として登録**」のどちらか（またはキャンセル）を一度だけ聞く。
- 誤入力や表記ゆれがそのままマスタに入るのを防ぎ、データの質を保てる。

### ③ プリセット（定型）機能

- よく使う組み合わせ（例：序盤の標準的な宝箱）を **`template.json`** や設定内の「定型」として保存。
- エディタで「**テンプレートから作成**」を選ぶと、`obj_id` と `contents` が一括で入った状態から編集を開始し、**座標だけ変えて保存**すればよい。

---

## 採用の進め方

1. **まず「`contents` を配列で持つ」現行の保存形式を維持したまま**、ブログ出力やエクスポート時に「ID → 表示名」をマスタから解決するレイヤーを用意する。
2. **カテゴリに `id` を追加**（`category_master` の各項目に `id` フィールド）。保存時は `cat_id` を書き、表示・読込時は `id` ↔ 表示名で相互変換する。既存データは `category` 名から `cat_id` を逆引きする互換処理を挟む。
3. **`updated_at`** を保存項目に追加し、ブログ側のキャッシュや「最終更新」表示に使う。
4. 余力があれば **①〜③のエディタ挙動**（landmark 時は追加ボタン無効、新規登録時の確認、定型）を順に実装する。

この順で進めれば、**データ軽量化**と**ブログ表示の柔軟性**を両立した形に、段階的に寄せていけます。

---

## 実装済み：ID管理（生存戦略）・updated_at

- **cat_id** … `category_master` に各カテゴリの `id`（例: blueprint, lem）を追加。保存時は `categories` の各スロットに `cat_id` を書き、読込時は `cat_id` からマスタで表示名を解決。既存データは `category`（表示名）でそのまま読める。
- **Settings** … カテゴリ行に「ID」入力欄を追加。未入力なら name_en から自動生成して保存。
- **updated_at** … ピン保存時に `YYYY-MM-DDTHH:MM:SS` 形式で記録。CSV の列に含め、ブログ・キャッシュ用に利用可能。

## 実装済み：マスタ自動追加時の確認

- 保存時に、**マスタに存在しないカテゴリ・アイテム**があるとダイアログを表示。
- 「以下の項目がマスタにありません。追加してから保存しますか？」で【カテゴリ】と【アイテム】の一覧を表示。
- 「はい」でマスタに追加してから保存、「いいえ」で保存をキャンセルし入力内容を確認できる。

## 実装済み：プリセット（定型）

- **定型から作成** … サイドバー「▼ カテゴリ」横の「📋 定型から作成」で、保存済み定型の一覧を表示。選択するとオブジェクト＋中身スロットをフォームに一括反映。あとは地図で座標をクリックして保存。
- **定型に保存** … フッターの「📋 定型に保存」で、現在のオブジェクト・カテゴリ・アイテム・重要度を定型として登録。`templates.json`（ゲームフォルダ内）に保存。
- 定型データは `attribute_id` / `obj_attributes` / `categories` / `importance` を保持。名前は一覧表示・管理用。

## エディタの画面遷移・コード構造

### 画面遷移の流れ

1. **オブジェクト選択**（必須）
   - コンボボックスで「見た目」を選択。
   - → **landmark** のとき: 中身エリア（カテゴリ・アイテム）を**非表示**、追加ボタン無効（ルール①）。
   - → それ以外: 中身エリアを表示し、**同じ type のカテゴリだけ**をフィルタして表示。オブジェクトに属性（例：遺体の「場所」）があればその入力欄を表示。

2. **カテゴリ選択**（中身エリア内・複数可）
   - スロットごとにカテゴリを選択。
   - → **(なし)** のとき: アイテムは「(なし)」のみ、数量は表示。
   - → **qty_only**（例：戦時債権）: **アイテム選択を非表示**、数量入力のみ表示。
   - → **item_select**（例：設計図・LEM）: アイテム一覧を表示し、数量の表示/非表示は `show_qty` に従う。

3. **アイテム選択**（item_select のとき）
   - アイテムを選択。
   - → そのアイテムに **attributes** がある場合: そのスロットの下に属性エリアを表示。
   - → **fixed**（例：交換アイテムのポイント）: 値は**表示のみ**（ルール②）。
   - → **select**（例：LEM のランク）: セレクト/ラジオを表示。
   - → **number**: 入力欄を表示（現状は主にマスタ登録用）。

### 主要な処理の責務（editor.py）

| 処理 | 責務 |
|------|------|
| **on_attribute_changed** | オブジェクト変更時。`obj_type` を取得し、ルール①に従って中身エリアの表示/非表示と追加ボタンの有効/無効を切り替え。オブジェクト属性があれば `show_object_attributes` で表示。`update_category_list_by_type` でカテゴリを type フィルタ。 |
| **on_slot_category_changed** | スロットのカテゴリ変更時。そのスロットの属性エリアをクリア。`input_type`（qty_only / item_select）と `show_qty` に従い、アイテム選択・数量の表示/非表示を切り替え。item_select のときは `item_master` からアイテム一覧をセット。 |
| **on_slot_item_changed** | スロットのアイテム変更時。そのスロットの属性エリアをクリア後、選択アイテムの `attributes` に応じて fixed（表示のみ）/ select / number のウィジェットを生成。 |
| **show_object_attributes** | オブジェクトに属性があるとき、`obj_attr_frame` に number / select の入力欄を生成。 |
| **update_category_list_by_type** | `filtered_category_list` を obj_type でフィルタし、全スロットのカテゴリコンボボックスの values を更新。 |

### データの流れ（保存・読込）

- **保存**: `save_data` がスロットから `categories_data`（各要素に `cat_id`, `category`, `item_id`, `qty`, `attributes`）を組み立て、マスタにないカテゴリ・アイテムは確認ダイアログ後に追加。CSV に `categories`（JSON）、`obj_attributes`（JSON）、`updated_at` を書き出す。
- **読込**: `load_to_ui` が `attribute` → オブジェクト設定、`obj_attributes` → オブジェクト属性、`categories` → `cat_id` から表示名を解決しつつスロットを追加・各ウィジェットに値をセット。

---

## 実装済み：UIラベルの統一

- ピン編集画面: **「▼ オブジェクト（見た目・外形）」** / **「▼ 中身の分類（カテゴリ）」** / **「＋ 中身を追加」** / スロットの **「分類:」** / **「▼ 詳細メモ（日本語）」** に統一。
- 用語を「オブジェクト＝見た目」「カテゴリ＝中身の分類」「アイテム＝中身の具体」に揃え、何を入力しているか分かりやすくした。

---

## 実装済み：ブログ出力レイヤー

- **ブログ用エクスポート** … フッターの「📤 ブログ用エクスポート」で、全ピンを **ID → 表示名解決** した JSON に書き出す。
- 出力先: ゲームフォルダ内 **`pins_export.json`**。形式は `{ "pins": [ { "id", "coords", "obj_id", "obj_jp", "obj_en", "obj_props", "contents": [ { "cat_id", "cat_jp", "cat_en", "item_id", "item_jp", "item_en", "qty", "props" }, ... ], "importance", "memo_jp", "memo_en", "updated_at" }, ... ] }`。ブログ側ではこの JSON を読み、表示名（obj_jp/en, cat_jp/en, item_jp/en）をそのまま表示できる。
- 実装: `src/export_utils.py` の `resolve_pin_for_display` / `export_pins_to_json`。

---

## ブログでの表示（埋め込み仕様）

ブログ側では **Leaflet** とリポジトリの **map.js** で地図を表示している。表示の細かい仕様はページごとに最適化し、`data-*` 属性やスタイルで調整する。

### 基本の埋め込み

- **Leaflet**: `leaflet@1.9.4` の CSS / JS を CDN で読み込む。
- **コンテナ**: `#map-container` でラップし、その中に `#game-map` を置く。高さは `85vh` などで指定。
- **map.js**: ゲーム・リージョンごとの `map.js` を raw.githack 等で読み込む（例: `games/StarRupture/None/map.js`）。タイルとピンはこのスクリプトが描画する。

### #game-map の data 属性（ページごとの最適化）

| 属性 | 例 | 役割 |
|------|-----|------|
| **data-zoom** | `2` | 初期ズームレベル。 |
| **data-filter** | `blueprint` | 表示するピンを **cat_id** で絞る（例: 設計図だけ表示）。 |
| **data-show-labels** | `true` | ラベルを常時表示するか（ツールチップを常時表示するスタイルと連動）。 |

このほか、ページごとにスタイル（`.item-tooltip-permanent` の色・枠など）を上書きして、デザインや可読性を調整する。

### よくあるパターン

- **一覧用**: 全ピン表示、ズーム固定。全画面ボタン付き。
- **カテゴリ別ページ**: `data-filter="blueprint"` で設計図のみ表示し、`data-show-labels="true"` でアイテム名を常時表示。スタイルで枠色（例: 青）を統一。

エディタで保存するピンデータ（CSV / `pins_export.json`）の **cat_id** と、ブログの **data-filter** を揃えておくと、ページごとのフィルタ表示がそのまま使える。

---

## ブログ実装の流れ（何を用意するか）

- **地図そのもの**: Leaflet と既存の **map.js** をそのまま転用してよい。タイル・初期表示・ズームなどは map.js が担当。
- **地図タイル**: 現在使っている地図データ（タイル画像や設定）がそのまま使えるなら、そのまま利用。
- **ピンデータ**: ブログ側で必要なのは **「表示用に解決済みのピン一覧」** だけ。エディタの「📤 ブログ用エクスポート」で出力する **`pins_export.json`** がその形式（`obj_jp` / `obj_en`、`contents[].cat_jp` / `item_jp` など表示名解決済み）。ブログ（または map.js）はこの JSON を読み、座標と表示名を使ってピンを打てばよい。

まとめ: **地図機能は転用、中身のデータは `pins_export.json` を用意してブログから参照する**形でよい。

---

## ピンデータの共有方法（ブログにどう渡すか）

ブログはどこかから `pins_export.json`（または同等のピン一覧）を取得する必要がある。選択肢とトレードオフは以下のとおり。

| 方法 | やり方 | 反映の速さ | おすすめ度 |
|------|--------|------------|------------|
| **GitHub リポジトリ** | エクスポートした `pins_export.json` をリポジトリにコミットし、ブログでは `raw.githubusercontent.com/.../pins_export.json` や **jsDelivr**（`cdn.jsdelivr.net/gh/user/repo/...`）で取得 | プッシュ後も CDN/キャッシュで数分〜しばらく古い内容が返ることがある | 運用がシンプルなら依然あり。キャッシュ対策をすると多少マシ。 |
| **GitHub + キャッシュ対策** | 上記に加え、取得 URL に **クエリでバージョン** を付ける（例: `pins_export.json?v=20250101` や `?t=<updated_at>`）。ブログ側で「エクスポートした日」や「最終 updated_at」をクエリに含めると、データ更新後にブログを書き換えれば新しい JSON が読まれる | ブログ記事の修正（URL のクエリ更新）か、ビルド時に最新コミットを参照する必要あり | 反映を「ブログ更新時」に合わせるなら現実的。 |
| **jsDelivr で GitHub を参照** | `https://cdn.jsdelivr.net/gh/<user>/<repo>@<branch>/path/to/pins_export.json` のように **ブランチ＋パス** で固定。jsDelivr は GitHub のタグ/リリースやコミットを指定できるので、「このコミットのファイル」を明示するとキャッシュの挙動が読みやすい | タグやコミットを打つたびに URL を変えれば確実に最新を取れる。ブランチ指定だけだとキャッシュで遅れる可能性はある | GitHub を使い続ける場合の「やや反映を速くする」選択肢。 |
| **別のホスティングに JSON だけ置く** | Netlify / Vercel / 自前サーバなどに **pins_export.json だけ** をデプロイ。エディタでエクスポート → そのファイルをアップロード or 同じリポジトリの別サイトとしてデプロイ | デプロイが終わればすぐ反映。GitHub の raw よりコントロールしやすい | **反映を速くしたいときのおすすめ**。 |
| **ブログビルド時に取り込む** | ブログを静的生成（Hugo / 11ty など）している場合、ビルド時に GitHub や URL から `pins_export.json` を取得し、**静的ファイルとして同梱** する | 反映 = ブログの再ビルド・再デプロイのタイミング。ピンだけ更新してもブログをデプロイしないと変わらない | 更新頻度が低いなら十分。 |

**おすすめの整理**

- **「エディタで更新 → できるだけ早くブログに反映したい」**: GitHub の raw はキャッシュで遅くなりがちなので、**pins_export.json だけ別ホスティング（Netlify/Vercel など）に置く**か、**GitHub + jsDelivr でタグ/コミット指定** する運用がおすすめ。
- **「今のまま GitHub でよい」**: その場合でも、**取得 URL に `?v=日付` などを付けてキャッシュをバイパス** するか、**ブログ側で「ピン用 JSON の URL」を記事ごとに書き換えられるようにしておく**と、反映が遅いと感じたときに調整しやすい。
- **地図タイル** は容量が大きいので、従来どおり GitHub や既存の配信経路で問題ない。共有したい「更新されがちなもの」は **ピン用 JSON だけ** に絞ると、ホスティングの選択肢が広がる。

---

## 既存のものを改修版で置き換える手順（GitHub 運用）

GitHub のままで運用する場合、**コード**と**データ**の両方を「今の改修版」で置き換える流れは次のとおり。

### 1. コードの置き換え（エディタ本体を GitHub に反映）

1. ローカルで改修した内容をコミットする。
   ```bash
   git add src/ games/ docs/ main.py  # 変更したファイルを必要に応じて指定
   git commit -m "エディタ改修: UI統一・EN入力・エクスポートなど"
   ```
2. リモート（GitHub）にプッシュする。
   ```bash
   git push origin main
   ```
3. これで GitHub 上のリポジトリが「今の改修版」になる。他の環境で使う場合は `git pull` すれば同じ状態になる。

### 2. データの置き換え（ピン・マスタを新形式で揃える）

- **エディタ用データ（config.json / master_data.csv）**  
  - 既にローカルで新形式に移行済みなら、そのままコミットしてプッシュすれば GitHub 上も新形式に置き換わる。  
  - まだ移行していない場合は、`scripts/migrate_master_data_to_spec.py` で CSV を新形式に変換してからコミットする。
- **ブログ用データ（pins_export.json）**  
  1. エディタで「📤 ブログ用エクスポート」を実行し、`games/<ゲーム>/<地図>/pins_export.json` を出力する。  
  2. そのファイルをコミットしてプッシュする。  
  3. ブログ側では、このリポジトリの `pins_export.json` を参照する URL（raw または jsDelivr）を**既存の URL から新しいパスに切り替える**。  
     - 例: これまで `.../old-branch/.../pins.json` を使っていた → `.../main/.../games/StarRupture/None/pins_export.json` に変更。  
  4. キャッシュ対策として、URL に `?v=20250201` のように日付やバージョンを付けておくと、更新後にブログでクエリだけ変えれば新しい JSON が読まれる。

### 3. ブログ側で「既存の表示」を新しいデータに切り替えるだけにする場合

- ブログの地図読み込み部分で、**ピン用 JSON の URL を1箇所で指定**しているなら、その URL を「改修版のリポジトリ（またはブランチ）の `pins_export.json`」に差し替えるだけで、既存の表示が新しいデータに置き換わる。  
- 複数記事で別々の URL を書いている場合は、そのすべてを新しい `pins_export.json` の URL（＋必要なら `?v=...`）に更新する。

**まとめ**: コードは `git add` → `commit` → `push` で GitHub を改修版に合わせ、データは新形式の `config.json` / `master_data.csv` とエクスポートした `pins_export.json` をコミットしてから、ブログの参照 URL を新しいファイルに切り替えれば、既存のものを改修版で置き換えられる。

---

## 次のステップ候補

- 特になし。
